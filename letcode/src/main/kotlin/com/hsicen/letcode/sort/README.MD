##### 排序算法执行效率

- 时间复杂度
  - ==最好==时间复杂度：在最理想的情况下，执行这段代码的时间复杂度
  - ==最坏==时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度
  - ==平均==时间复杂度：在平均情况下，执行这段代码的时间复杂度；每种情况出现的概率÷情况总数
  - ==均摊==时间复杂度：把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路
- 时间复杂度的系数、常数 、低阶
- 比较次数和交换（或移动）次数

##### 算法的内存消耗

> 算法的内存消耗可以通过空间复杂度来衡量s
>
> ==原地排序==：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法

##### 排序算法的稳定性

> 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变,则为稳定排序算法，反之则为不稳定排序算法

##### 有序度和逆序度

> 有序度：数组中具有有序关系的元素对的个数；如果`i<j`,则`a[i] <= a[j]`
>
> 逆序度：与有序度的定义相反，如果`i<j`,则`a[i] > a[j]`
>
> 满有序度：一个有序数组的有序度为：`n*(n-1)/2`
>
> 一个数组排序的交换次数：满有序度-初识有序度

##### 排序算法

 - `线性排序`算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法
 - 如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数
 - `堆排序`和`快速排序`时间复杂度都是 O(nlogn)，Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数
 - 快排在最坏情况下的时间复杂度是 O(n2)，而`归并排序`可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，但是由于归并排序额外的空间占用，故对于数据量很大的排序并不是很常用

##### 快排优化

如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)；实际上，这种 `O(n2)` 时间复杂度出现的主要原因还是因为我们分区点选得不够合理。

最`理想的分区点`是：被分区点分开的两个分区中，数据的数量差不多。

- `三数取中`法：我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。
- 随机法：每次从要排序的区间中，随机选择一个元素作为分区点。

递归堆栈溢出问题

- 限制递归深度，超过设定的阀值就停止递归
- 在堆栈上模拟实现一个函数的调用栈，手动模拟递归压栈、出栈过程，这样就没了系统堆栈大小的限制

##### 排序算法思路

当输入数据较少时可以使用归并排序，以空间换取时间；当数据量较大时使用快速排序

O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长，因为我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数



