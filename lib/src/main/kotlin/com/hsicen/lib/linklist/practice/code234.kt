package com.hsicen.lib.linklist.practiceimport java.util.*/** * 作者：hsicen  8/13/21 09:22 * 邮箱：codinghuang@163.com * 作用： * 描述：回文链表 * Given a singly linked list, determine if it is a palindrome. */// 利用快慢指针找到中间位置，同时反转慢指针走过的结点，// 然后慢指针继续遍历后半段，和反转的前半段对比，看是否为回文串fun isPalindrome(head: ListNode?): Boolean {    if (head?.next == null) return true    var fast = head    var slow = head    var prev: ListNode? = null    while (fast?.next != null) {        fast = fast.next?.next        val next = slow?.next        slow?.next = prev        prev = slow        slow = next    }    if (null != fast) {        slow = slow?.next    }    while (null != prev && null != slow) {        if (prev.`val` != slow.`val`) {            return false        }        prev = prev.next        slow = slow.next    }    return true}// 利用栈来判断是否为回文字符串// 将数据全部压入栈中然后再从链表头部遍历判断fun isPalindrome1(head: ListNode?): Boolean {    val reverseData = Stack<Int>()    var tmp = head    while (null != tmp) {        reverseData.push(tmp.`val`)        tmp = tmp.next    }    var newHead = head    while (!reverseData.empty()) {        val top = reverseData.pop()        if (newHead?.`val` != top) {            return false        }        newHead = newHead?.next    }    return true}fun isPalindrome2(head: ListNode?): Boolean {    if (null == head?.next) return true    var fast = head    var slow = head    val halfStack = Stack<Int>()    while (null != fast?.next) {        halfStack.push(slow?.`val`)        fast = fast.next?.next        slow = slow?.next    }    // 奇偶处理    if (null != fast) slow = slow?.next    while (!halfStack.empty() && null != slow) {        if (slow.`val` != halfStack.pop()) return false        slow = slow.next    }    return true}fun main() {    val listNode = ListNode(1)    addNodeEnd(listNode, 0)    addNodeEnd(listNode, 1)    println(isPalindrome2(listNode))}